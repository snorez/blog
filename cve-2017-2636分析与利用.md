# 基本信息
在drivers/tty/n_hdlc.c中存在竞争条件, 同一个对象可以两次被加入到一个将被free的链表中, 然后导致double free.

# 分析
[作者的文档](https://a13xp0p0v.github.io/2017/03/24/CVE-2017-2636.html)

# 一些细节
+ 在最开始的调试中, 发现kfree函数会改写被释放空间的首个unsigned long数据,
	后来发现这个数据是用来记录前一个释放的空间的地址.
	用如下模块测试
	```c
	ptr0 = kmalloc(8192, ...);
	ptr1 = kmalloc(8192, ...);
	kfree(ptr0);
	*(unsigned long *)ptr0 = ptr0+0x4000;	/* this value is not ptr1 */
	kfree(ptr1);
	kmalloc(8192, ...);			/* return ptr1 */
	kmalloc(8192, ...);			/* return ptr0+0x4000 */
	```
+ 在触发double free时,
	`prev = last rx_free_buf_list`
	`buf0 = first tx_free_buf_list`
	`buf1 = buf0->link`
	`buf2 = buf1->link`
	`buf3 = buf2`
	因为在释放的时候, 会把->link的数据改写为之前释放的空间地址, 释放的顺序为
	prev buf0 buf1 buf2 **buf2** buf1 buf0 prev
	***此时buf1和buf2的首个unsigned long数据均为buf2***, 也就是说, 后续的
	申请会得到两个对象指向同一个空间地址的情况
+ [double free 类型漏洞的利用](https://github.com/snorez/blog/blob/master/linux%20kernel%20double-free%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8.md)
